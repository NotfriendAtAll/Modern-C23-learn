[TOC]
###  __has_include 是 C/C++ 预处理器引入的特性，用于在编译前检查指定头文件是否存在
- ​作用​：检查指定头文件是否可被编译器找到（不实际包含内容），返回布尔值（1 表示存在，0 表示不存在）。
- ​用途​：根据目标系统或环境动态调整头文件包含策略，避免因缺失头文件导致编译失败。
- 提醒:
1. 支持情况​：
- Clang：广泛支持（现代版本均兼容）。
- GCC：≥5.0 版本支持（建议使用 ≥7.0 确保稳定性）。
2. 不支持情况​：
- MSVC​：部分旧版本不支持，需改用其他条件编译方法（如检查预定义宏  _MSVC_VER）。
- ​IAR 等嵌入式编译器​：如用户反馈 IAR 8.40.1 会报错（错误类型 - Pe059、Pe031），因其未实现此特性。
***
### 符号位和补码​符号位的作用与补码表示法​
- 背景：
-  ​历史表示法的淘汰​
- C23标准淘汰了以下两种旧式负数表示法，仅保留补码：
 原码（Sign and Magnitude）​
​反码（Ones' Complement）​​
- 有符号类型通过符号位区分正负：
​符号位位置​：最高位（MSB），0为正，1为负。
​C23标准强制要求补码（Two's Complement）​​：
- 补码规则​：负数的补码 = 绝对值的二进制取反 + 1。
​优势​：统一加减法运算，避免正负零问题。
```bash
-1 的补码：11111111（0xFF），解释为无符号数即255
```
***
### 编译器对有符号溢出的优化机制
- 编译器优化逻辑​
​前提假设​：编译器基于C标准允许假设程序无UB，故认为：
i 初始值 1 > 0 → 若程序行为定义良好，则 i 永不满足 i <= 0。
循环条件 i != 0 恒成立（除非溢出，但溢出是UB，故忽略）。
- ​优化结果​：
```cpp
while (true) do_something();  // 死循环[3,4](@ref)
```
- ​关键原理​：编译器利用 ​as-if规则​（Takeaway 5.1.3 #3），在可观测行为一致的前提下，将可能触发UB的代码替换为等效高效实现。
- ​as-if规则​：编译器必须将可能触发UB的代码替换为等效高效实现，但必须保证可观测行为一致。
***
### 固定宽度整数类型系统
- 标准类型与位宽​
基础类型​：
int8_t/uint8_t、int16_t/uint16_t、int32_t/uint32_t、int64_t/uint64_t 是 C99/C++11 标准中明确定义的固定宽度类型，宽度分别为 8/16/32/64 位。
- ​128 位扩展​：
int128_t/uint128_t ​非 C 标准强制要求，但现代编译器（如 GCC/Clang）通过扩展提供支持（例如 __int128/unsigned __int128）。其位宽为 128 位，需硬件支持（如 x86-64 的 SSE 指令集）。
```bash
UINTN_MAX = (2^N) - 1
INTN_MAX  = 2^(N-1) - 1
INTN_MIN  = -2^(N-1)
```
***
- C23 新式格式化：%wN 说明符​
语法​：%wN<format>
- N：类型位宽（如 64、128）
<format>：基础格式符（如 d、u、x）
```bash
uint32_t n = 78;
int64_t big = INT64_MAX;
printf("n = %w32u, big = %w64d\n", n, big); // 直接指定位宽[10](@ref)
```
***
### c99的C语言中固定长度数组（FLAs，即原文中的CLAs）和变长数组（VLAs）的核心特性
FLAs​：编译期确定长度，支持任意初始化，无作用域限制，sizeof 在编译期完成。
VLAs​：运行时确定长度，禁止初始化和全局使用，sizeof 在运行时计算。
​长度计算​：sizeof(A) / sizeof(A[0]) 是通用方法，但需警惕指针退化问题。
​- C23部分恢复VLA支持，但自动VLA仍非强制特性，跨平台代码需检测_  STDC_NO_VLA_
